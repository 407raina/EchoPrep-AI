/**
 * AI Interview Service - Handles interview question generation and feedback analysis
 */
import Groq from "groq-sdk";
import { query } from "../db/pool";
import {
  QuestionGenerationParams,
  GeneratedQuestion,
  InterviewQuestion,
  CreateQuestionInput,
  InterviewFeedback,
  CategoryFeedback,
  InterviewAnswer,
} from "../types/interview";

/**
 * Generate interview questions using Groq (Llama 3.1 70B) based on job role and experience level
 */
export async function generateInterviewQuestions(
  params: QuestionGenerationParams,
  groqApiKey: string
): Promise<GeneratedQuestion[]> {
  const { jobRole, experienceLevel, numberOfQuestions = 7 } = params;

  const groq = new Groq({ apiKey: groqApiKey });

  const systemPrompt = `You are an expert technical recruiter and interviewer with deep knowledge of ${jobRole} roles.

Generate ${numberOfQuestions} interview questions for a ${experienceLevel} ${jobRole} candidate.

Mix the following question types:
1. Technical questions (40%) - Role-specific technical knowledge, tools, methodologies
2. Behavioral questions (30%) - STAR method scenarios, past experiences
3. Situational questions (20%) - Hypothetical scenarios, problem-solving
4. Experience questions (10%) - Past projects, achievements, challenges

For ${experienceLevel} level:
- Fresher/Entry-level: Focus on fundamentals, learning ability, potential
- Mid-level: Balance technical depth with team collaboration and project ownership
- Senior: Strategic thinking, leadership, architecture, mentoring

Return valid JSON object with this exact structure:
{
  "questions": [
    {
      "question_text": "Clear, specific question text",
      "category": "technical|behavioral|situational|experience|general",
      "difficulty": "easy|medium|hard"
    }
  ]
}

Make questions realistic, relevant, and appropriate for the role and level.`;

  try {
    const completion = await groq.chat.completions.create({
      model: "llama-3.3-70b-versatile",
      messages: [
        {
          role: "system",
          content: "You are an expert technical recruiter. Always respond with valid JSON only.",
        },
        {
          role: "user",
          content: systemPrompt,
        },
      ],
      temperature: 0.8,
      max_tokens: 2048,
      response_format: { type: "json_object" },
    });

    const text = completion.choices[0]?.message?.content;

    if (!text) {
      console.warn("No response from Groq, using fallback questions");
      return generateFallbackQuestions(jobRole, experienceLevel, numberOfQuestions);
    }

    const parsed = JSON.parse(text);
    
    // Handle both direct array and wrapped object responses
    const questions = Array.isArray(parsed) ? parsed : (parsed.questions || []);
    
    if (!questions || questions.length === 0) {
      console.warn("No questions generated by Groq, using fallback");
      return generateFallbackQuestions(jobRole, experienceLevel, numberOfQuestions);
    }
    
    return questions as GeneratedQuestion[];
  } catch (error) {
    console.error("Error generating questions with Groq:", error);
    console.warn("Using fallback questions due to Groq API error");
    
    // Use fallback questions instead of throwing error
    return generateFallbackQuestions(jobRole, experienceLevel, numberOfQuestions);
  }
}

/**
 * Generate fallback questions when Groq is unavailable
 */
function generateFallbackQuestions(
  jobRole: string,
  experienceLevel: string,
  numberOfQuestions: number = 7
): GeneratedQuestion[] {
  const allQuestions: GeneratedQuestion[] = [
    {
      question_text: `Tell me about your background and experience relevant to the ${jobRole} role.`,
      category: "experience",
      difficulty: "easy",
    },
    {
      question_text: "What are your greatest technical strengths, and how have you applied them in your work?",
      category: "technical",
      difficulty: "easy",
    },
    {
      question_text: "Describe a challenging project you worked on. What was your role, and how did you overcome obstacles?",
      category: "behavioral",
      difficulty: "medium",
    },
    {
      question_text: "How do you stay updated with industry trends and new technologies in your field?",
      category: "behavioral",
      difficulty: "easy",
    },
    {
      question_text: "Walk me through your problem-solving approach when facing a complex technical issue.",
      category: "technical",
      difficulty: "medium",
    },
    {
      question_text: "Tell me about a time you had to work with a difficult team member. How did you handle it?",
      category: "situational",
      difficulty: "medium",
    },
    {
      question_text: "Where do you see yourself in your career in the next 3-5 years?",
      category: "behavioral",
      difficulty: "easy",
    },
    {
      question_text: `What interests you most about this ${jobRole} position?`,
      category: "general",
      difficulty: "easy",
    },
    {
      question_text: "Describe a time when you had to learn a new technology or skill quickly. How did you approach it?",
      category: "behavioral",
      difficulty: "medium",
    },
    {
      question_text: "How do you prioritize tasks when working on multiple projects with tight deadlines?",
      category: "situational",
      difficulty: "medium",
    },
  ];

  // Return the requested number of questions
  return allQuestions.slice(0, Math.min(numberOfQuestions, allQuestions.length));
}

/**
 * Store a question in the database
 */
export async function createInterviewQuestion(
  input: CreateQuestionInput
): Promise<InterviewQuestion> {
  const result = await query(
    `INSERT INTO interview_questions 
      (interview_session_id, question_number, question_text, category, difficulty)
     VALUES ($1, $2, $3, $4, $5)
     RETURNING *`,
    [
      input.interview_session_id,
      input.question_number,
      input.question_text,
      input.category || null,
      input.difficulty || null,
    ]
  );

  return result.rows[0] as InterviewQuestion;
}

/**
 * Get all questions for an interview session
 */
export async function getSessionQuestions(
  sessionId: string
): Promise<InterviewQuestion[]> {
  const result = await query(
    `SELECT * FROM interview_questions 
     WHERE interview_session_id = $1 
     ORDER BY question_number ASC`,
    [sessionId]
  );

  return result.rows as InterviewQuestion[];
}

/**
 * Get a specific question by ID
 */
export async function getQuestionById(questionId: string): Promise<InterviewQuestion | null> {
  const result = await query(
    `SELECT * FROM interview_questions WHERE id = $1`,
    [questionId]
  );

  return result.rowCount ? (result.rows[0] as InterviewQuestion) : null;
}

/**
 * Store an answer in the database
 */
export async function createInterviewAnswer(
  sessionId: string,
  questionId: string,
  answerText: string,
  transcriptionConfidence?: number,
  audioDuration?: number,
  audioFilePath?: string
): Promise<InterviewAnswer> {
  const result = await query(
    `INSERT INTO interview_answers 
      (interview_session_id, question_id, answer_text, transcription_confidence, audio_duration, audio_file_path)
     VALUES ($1, $2, $3, $4, $5, $6)
     RETURNING *`,
    [
      sessionId,
      questionId,
      answerText,
      transcriptionConfidence || null,
      audioDuration || null,
      audioFilePath || null,
    ]
  );

  return result.rows[0] as InterviewAnswer;
}

/**
 * Get all answers for a session
 */
export async function getSessionAnswers(sessionId: string): Promise<InterviewAnswer[]> {
  const result = await query(
    `SELECT a.*, q.question_number, q.question_text, q.category
     FROM interview_answers a
     JOIN interview_questions q ON a.question_id = q.id
     WHERE a.interview_session_id = $1
     ORDER BY q.question_number ASC`,
    [sessionId]
  );

  return result.rows as InterviewAnswer[];
}

/**
 * Calculate precise score with transparent breakdown
 * New scoring breakdown:
 * - Content & Relevance: 50 points (50%)
 * - Detail & Depth: 20 points (20%)
 * - Fluency & Clarity: 15 points (15%)
 * - Confidence & Tone: 10 points (10%)
 * - Grammar & Structure: 5 points (5%)
 */
function calculateTransparentScore(
  contentScore: number,       // 0-50
  detailScore: number,         // 0-20
  fluencyScore: number,        // 0-15
  confidenceScore: number,     // 0-10
  grammarScore: number         // 0-5
): { total: number; breakdown: any } {
  // Ensure scores are within valid ranges
  const content = Math.max(0, Math.min(50, contentScore));
  const detail = Math.max(0, Math.min(20, detailScore));
  const fluency = Math.max(0, Math.min(15, fluencyScore));
  const confidence = Math.max(0, Math.min(10, confidenceScore));
  const grammar = Math.max(0, Math.min(5, grammarScore));

  // Calculate total
  const rawTotal = content + detail + fluency + confidence + grammar;
  const total = Math.round(rawTotal);

  return {
    total,
    breakdown: {
      contentRelevance: { score: Math.round(content), maxScore: 50, percentage: 50 },
      detailDepth: { score: Math.round(detail), maxScore: 20, percentage: 20 },
      fluencyClarity: { score: Math.round(fluency), maxScore: 15, percentage: 15 },
      confidenceTone: { score: Math.round(confidence), maxScore: 10, percentage: 10 },
      grammarStructure: { score: Math.round(grammar), maxScore: 5, percentage: 5 },
    }
  };
}

/**
 * Analyze answer quality metrics for more precise scoring
 */
function analyzeAnswerQuality(conversationPairs: any[]): {
  avgAnswerLength: number;
  technicalDepth: number;
  structureScore: number;
  specificityScore: number;
} {
  if (conversationPairs.length === 0) {
    return { avgAnswerLength: 0, technicalDepth: 0, structureScore: 0, specificityScore: 0 };
  }

  // Calculate average answer length (words)
  const avgLength = conversationPairs.reduce((sum, pair) => {
    const wordCount = pair.answer.trim().split(/\s+/).length;
    return sum + wordCount;
  }, 0) / conversationPairs.length;

  // Assess technical depth (presence of technical terms, examples)
  const technicalKeywords = ['architecture', 'design', 'implement', 'optimize', 'algorithm', 
                             'database', 'api', 'system', 'performance', 'scalability', 
                             'framework', 'library', 'testing', 'deployment'];
  const technicalDensity = conversationPairs.reduce((sum, pair) => {
    const lowerAnswer = pair.answer.toLowerCase();
    const matches = technicalKeywords.filter(kw => lowerAnswer.includes(kw)).length;
    return sum + matches;
  }, 0) / conversationPairs.length;

  // Assess structure (presence of organized thought - connectors, examples)
  const structureKeywords = ['first', 'second', 'then', 'finally', 'because', 'therefore', 
                             'for example', 'specifically', 'additionally', 'however'];
  const structureDensity = conversationPairs.reduce((sum, pair) => {
    const lowerAnswer = pair.answer.toLowerCase();
    const matches = structureKeywords.filter(kw => lowerAnswer.includes(kw)).length;
    return sum + matches;
  }, 0) / conversationPairs.length;

  // Assess specificity (numbers, specific examples, details)
  const specificityMarkers = /\d+|specific|example|project|experience|implemented|achieved|resulted/gi;
  const specificityScore = conversationPairs.reduce((sum, pair) => {
    const matches = (pair.answer.match(specificityMarkers) || []).length;
    return sum + matches;
  }, 0) / conversationPairs.length;

  return {
    avgAnswerLength: avgLength,
    technicalDepth: Math.min(10, technicalDensity * 2), // Scale to 0-10
    structureScore: Math.min(10, structureDensity * 3), // Scale to 0-10
    specificityScore: Math.min(10, specificityScore * 1.5) // Scale to 0-10
  };
}

/**
 * Generate AI feedback for completed interview with enhanced precision
 */
export async function generateInterviewFeedback(
  sessionId: string,
  groqApiKey: string
): Promise<InterviewFeedback> {
  // Get questions and answers
  const answersData = await query(
    `SELECT 
       q.question_number,
       q.question_text,
       q.category,
       q.difficulty,
       a.answer_text,
       a.transcription_confidence,
       a.audio_duration
     FROM interview_answers a
     JOIN interview_questions q ON a.question_id = q.id
     WHERE a.interview_session_id = $1
     ORDER BY q.question_number ASC`,
    [sessionId]
  );

  const sessionData = await query(
    `SELECT metadata, duration FROM interview_sessions WHERE id = $1`,
    [sessionId]
  );

  if (!answersData.rowCount || !sessionData.rowCount) {
    throw new Error("Interview session or answers not found");
  }

  const rawMetadata = sessionData.rows[0].metadata;
  const metadata = typeof rawMetadata === 'string' 
    ? JSON.parse(rawMetadata) 
    : rawMetadata || {};
  const jobRole = metadata.jobRole || "Software Developer";
  const experienceLevel = metadata.experienceLevel || "Mid-level";
  const sessionDuration = sessionData.rows[0].duration;

  // Build transcript for analysis
  const conversationPairs = answersData.rows.map((row) => ({
    question: row.question_text,
    answer: row.answer_text,
    category: row.category,
    difficulty: row.difficulty,
    confidence: row.transcription_confidence,
    duration: row.audio_duration
  }));

  // Analyze answer quality for enhanced scoring
  const qualityMetrics = analyzeAnswerQuality(conversationPairs);

  const groq = new Groq({ apiKey: groqApiKey });

  const systemPrompt = `You are an expert interview evaluator and career coach with extensive experience in ${jobRole} recruitment.

Analyze this ${experienceLevel} ${jobRole} interview and provide HIGHLY PRECISE, data-driven feedback.

**Answer Quality Metrics:**
- Average answer length: ${qualityMetrics.avgAnswerLength.toFixed(1)} words
- Technical depth score: ${qualityMetrics.technicalDepth.toFixed(1)}/10
- Structure score: ${qualityMetrics.structureScore.toFixed(1)}/10
- Specificity score: ${qualityMetrics.specificityScore.toFixed(1)}/10
- Total questions answered: ${conversationPairs.length}
${sessionDuration ? `- Interview duration: ${Math.round(sessionDuration / 60)} minutes` : ''}

**Precise Evaluation Criteria:**

1. **Communication Skills** (Exact Weight: 25 points max)
   - Clarity: 0-8 points (word choice, articulation)
   - Structure: 0-8 points (organization, logical flow)
   - Professionalism: 0-5 points (tone, language)
   - Engagement: 0-4 points (enthusiasm, confidence)
   
   **Scoring Guidelines:**
   - 20-25: Exceptional communicator, clear and professional
   - 15-19: Strong communication with minor areas to polish
   - 10-14: Adequate communication, needs improvement in clarity or structure
   - 0-9: Significant communication challenges

2. **Technical Knowledge** (Exact Weight: 40 points max)
   - Depth: 0-15 points (understanding of concepts)
   - Accuracy: 0-12 points (correctness of information)
   - Problem-solving: 0-8 points (analytical approach)
   - Experience: 0-5 points (practical application)
   
   **Scoring Guidelines:**
   - 32-40: Expert-level technical knowledge
   - 24-31: Strong technical foundation
   - 16-23: Adequate technical understanding
   - 0-15: Limited technical depth

3. **Behavioral Competencies** (Exact Weight: 35 points max)
   - STAR method: 0-12 points (structured examples)
   - Teamwork: 0-8 points (collaboration evidence)
   - Adaptability: 0-7 points (learning mindset)
   - Self-awareness: 0-8 points (growth orientation)
   
   **Scoring Guidelines:**
   - 28-35: Excellent behavioral competencies
   - 21-27: Strong behavioral skills
   - 14-20: Adequate behavioral understanding
   - 0-13: Limited behavioral demonstration

**CRITICAL INSTRUCTIONS:**
1. Use the quality metrics provided above to inform your scoring
2. Assign EXACT scores for each component based on the NEW transparent scoring system:
   - Content & Relevance: 0-50 points (Does the answer address the question? Is it relevant?)
   - Detail & Depth: 0-20 points (How detailed and thorough is the response?)
   - Fluency & Clarity: 0-15 points (Is the answer clear, well-articulated, and easy to follow?)
   - Confidence & Tone: 0-10 points (Does the candidate sound confident and professional?)
   - Grammar & Structure: 0-5 points (Is the answer grammatically correct and well-organized?)
3. Be STRICT - if answers are very short (< 10 words), score should be LOW (below 40)
4. Reference specific answers and provide evidence-based feedback
5. The overall score MUST equal: content + detail + fluency + confidence + grammar

Return valid JSON matching this EXACT structure:
{
  "score": <precise number 0-100, rounded to integer>,
  "scoreBreakdown": {
    "contentRelevance": <0-50>,
    "detailDepth": <0-20>,
    "fluencyClarity": <0-15>,
    "confidenceTone": <0-10>,
    "grammarStructure": <0-5>
  },
  "strengths": ["specific strength with evidence", "specific strength with evidence"],
  "improvementAreas": ["actionable improvement", "actionable improvement"],
  "summary": "2-3 sentence concise summary with specific score breakdown mentioned",
  "detailedAnalysis": {
    "contentRelevance": "Brief analysis of how well answers addressed questions",
    "detailDepth": "Brief analysis of answer thoroughness and depth",
    "fluencyClarity": "Brief analysis of communication clarity",
    "confidenceTone": "Brief analysis of confidence and professionalism",
    "grammarStructure": "Brief analysis of grammar and organization"
  },
  "analytics": {
    "avgAnswerLength": ${qualityMetrics.avgAnswerLength.toFixed(1)},
    "technicalDepth": ${qualityMetrics.technicalDepth.toFixed(1)},
    "structureScore": ${qualityMetrics.structureScore.toFixed(1)},
    "specificityScore": ${qualityMetrics.specificityScore.toFixed(1)},
    "questionsAnswered": ${conversationPairs.length}
  }
}`;

  const interviewTranscript = conversationPairs
    .map((pair, idx) => `Q${idx + 1} [${pair.category}${pair.difficulty ? ` - ${pair.difficulty}` : ''}]: ${pair.question}\nA${idx + 1} (${pair.answer.trim().split(/\s+/).length} words): ${pair.answer}`)
    .join("\n\n");

  const fullPrompt = `${systemPrompt}\n\nInterview Transcript for ${experienceLevel} ${jobRole}:\n\n${interviewTranscript}\n\nProvide PRECISE, evidence-based feedback in the specified JSON format. Use the quality metrics to inform your scoring.`;

  try {
    const completion = await groq.chat.completions.create({
      model: "llama-3.3-70b-versatile",
      messages: [
        {
          role: "system",
          content: "You are an expert interview evaluator specializing in precise, data-driven assessment. Always respond with valid JSON only. Be strict in your scoring - most candidates should score between 60-80.",
        },
        {
          role: "user",
          content: fullPrompt,
        },
      ],
      temperature: 0.5, // Lower temperature for more consistent scoring
      max_tokens: 4096,
      response_format: { type: "json_object" },
    });

    const text = completion.choices[0]?.message?.content;

    if (!text) {
      throw new Error("No feedback generated by Groq");
    }

    const feedback = JSON.parse(text);
    
    // Validate and recalculate final score with new transparent system
    if (feedback.scoreBreakdown) {
      const contentScore = parseFloat(feedback.scoreBreakdown.contentRelevance) || 0;
      const detailScore = parseFloat(feedback.scoreBreakdown.detailDepth) || 0;
      const fluencyScore = parseFloat(feedback.scoreBreakdown.fluencyClarity) || 0;
      const confidenceScore = parseFloat(feedback.scoreBreakdown.confidenceTone) || 0;
      const grammarScore = parseFloat(feedback.scoreBreakdown.grammarStructure) || 0;
      
      // Recalculate with new transparent scoring
      const result = calculateTransparentScore(
        contentScore,
        detailScore,
        fluencyScore,
        confidenceScore,
        grammarScore
      );
      
      feedback.score = result.total;
      feedback.scoreBreakdown = result.breakdown;
      
      // Add quality metrics if not present
      if (!feedback.analytics) {
        feedback.analytics = qualityMetrics;
        feedback.analytics.questionsAnswered = conversationPairs.length;
      }
    }
    
    return feedback as InterviewFeedback;
  } catch (error) {
    console.error("Groq API error generating feedback:", error);
    console.warn("Using metrics-based feedback due to Groq API error");
    
    // Calculate scores based on quality metrics as fallback using new transparent system
    const contentScore = Math.min(50,
      (qualityMetrics.specificityScore / 10) * 20 +
      (qualityMetrics.technicalDepth / 10) * 20 +
      10 // Base score
    );
    
    const detailScore = Math.min(20,
      (qualityMetrics.avgAnswerLength / 50) * 10 +
      (qualityMetrics.specificityScore / 10) * 8 +
      2 // Base score
    );
    
    const fluencyScore = Math.min(15,
      (qualityMetrics.structureScore / 10) * 10 +
      5 // Base score
    );
    
    const confidenceScore = Math.min(10,
      (qualityMetrics.avgAnswerLength / 50) * 5 +
      5 // Base score
    );
    
    const grammarScore = Math.min(5,
      (qualityMetrics.structureScore / 10) * 3 +
      2 // Base score
    );
    
    const result = calculateTransparentScore(
      contentScore,
      detailScore,
      fluencyScore,
      confidenceScore,
      grammarScore
    );
    const totalScore = result.total;
    
    return {
      score: totalScore,
      scoreBreakdown: result.breakdown,
      strengths: [
        `Answered ${conversationPairs.length} questions with an average of ${qualityMetrics.avgAnswerLength.toFixed(0)} words per answer`,
        `Demonstrated ${qualityMetrics.technicalDepth >= 5 ? 'good' : 'basic'} understanding in responses`,
        `Provided ${qualityMetrics.specificityScore >= 5 ? 'specific' : 'general'} examples and details`
      ],
      improvementAreas: [
        qualityMetrics.structureScore < 5 ? "Organize answers more clearly using frameworks" : "Continue refining answer structure",
        qualityMetrics.technicalDepth < 5 ? "Deepen knowledge with specific examples" : "Expand expertise to advanced topics",
        qualityMetrics.avgAnswerLength < 40 ? "Provide more detailed responses with concrete examples" : "Maintain response length with focused content"
      ],
      summary: `Interview completed with ${conversationPairs.length} questions answered. Overall score: ${totalScore}/100 based on Content & Relevance (${result.breakdown.contentRelevance.score}/50), Detail & Depth (${result.breakdown.detailDepth.score}/20), Fluency & Clarity (${result.breakdown.fluencyClarity.score}/15), Confidence & Tone (${result.breakdown.confidenceTone.score}/10), and Grammar & Structure (${result.breakdown.grammarStructure.score}/5).`,
      detailedAnalysis: {
        contentRelevance: `Content relevance scored ${result.breakdown.contentRelevance.score}/50. Responses ${qualityMetrics.specificityScore >= 5 ? 'demonstrated relevant' : 'showed basic'} understanding.`,
        detailDepth: `Detail and depth scored ${result.breakdown.detailDepth.score}/20. Answers averaged ${qualityMetrics.avgAnswerLength.toFixed(0)} words, indicating ${qualityMetrics.avgAnswerLength >= 40 ? 'thorough' : 'brief'} responses.`,
        fluencyClarity: `Fluency and clarity scored ${result.breakdown.fluencyClarity.score}/15. Structure score of ${qualityMetrics.structureScore.toFixed(1)}/10 indicates ${qualityMetrics.structureScore >= 6 ? 'well-organized' : 'adequate'} communication.`,
        confidenceTone: `Confidence and tone scored ${result.breakdown.confidenceTone.score}/10. Overall presentation was ${totalScore >= 70 ? 'professional' : 'adequate'}.`,
        grammarStructure: `Grammar and structure scored ${result.breakdown.grammarStructure.score}/5. Written responses were ${qualityMetrics.structureScore >= 6 ? 'well-structured' : 'adequately structured'}.`
      },
      analytics: {
        avgAnswerLength: parseFloat(qualityMetrics.avgAnswerLength.toFixed(1)),
        technicalDepth: parseFloat(qualityMetrics.technicalDepth.toFixed(1)),
        structureScore: parseFloat(qualityMetrics.structureScore.toFixed(1)),
        specificityScore: parseFloat(qualityMetrics.specificityScore.toFixed(1)),
        questionsAnswered: conversationPairs.length
      }
    };
  }
}

/**
 * Update interview session with feedback and mark as completed
 */
export async function completeInterviewWithFeedback(
  sessionId: string,
  feedback: InterviewFeedback
): Promise<void> {
  await query(
    `UPDATE interview_sessions 
     SET 
       status = 'completed',
       feedback = $1,
       score = $2,
       completed_at = NOW()
     WHERE id = $3`,
    [JSON.stringify(feedback), feedback.score, sessionId]
  );
}
